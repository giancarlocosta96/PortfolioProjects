Problem 1: https://platform.stratascratch.com/coding/10352-users-by-avg-session-time?code_type=5

Calculate each user's average session time. 
A session is defined as the time difference between a page_load and page_exit. 
For simplicity, assume a user has only 1 session per day and if there are multiple of the same events on that day, 
consider only the latest page_load and earliest page_exit, with an obvious restriction that load time event should 
happen before exit time event . Output the user_id and their average session time.

My Solution: 

WITH exit_load_times AS (
Select e.user_id, e.earliest_exit, l.latest_load
From 
(
Select user_id, Min(timestamp) as earliest_exit, action 
From facebook_web_log
Group by user_id, action, day(timestamp)
Having action='Page_exit') e
Join (
Select user_id, MAX(timestamp) as latest_load, action
From facebook_web_log
Group by user_id, action, day(timestamp)
Having action='Page_load') l
on e.user_id = l.user_id 
and day(e.earliest_exit)=day(l.latest_load)
)
Select user_id, CAST((AVG(DATEDIFF(Millisecond, latest_load, earliest_exit))*1.0/1000) AS Decimal(10,1)) AS average_time 
From exit_load_times 
Group by user_id 

Problem 2: https://platform.stratascratch.com/coding/2055-average-customers-per-city?code_type=5

Write a query that will return all cities with more customers than the average number of  
customers of all cities that have at least one customer. For each such city, return the country name,  
the city name, and the number of customers.

My Solution: 

With num_customers AS 
(Select count(*) as customers_per_city
      From linkedin_customers 
      Group by city_id
      Having count(*)>=1)
Select co.country_name, ci.city_name, count(cu.city_id)
From linkedin_customers cu
Join linkedin_city ci
On cu.city_id=ci.id
Join linkedin_country co
On ci.country_id=co.id
Group by co.country_name, ci.city_name
Having count(cu.city_id) > (Select AVG(customers_per_city)
      From num_customers )

Problem 3: https://platform.stratascratch.com/coding/10351-activity-rank?code_type=5

Find the email activity rank for each user. Email activity rank is defined by the total number of emails sent. 
The user with the highest number of emails sent will have a rank of 1, and so on. Output the user, total emails, 
and their activity rank. Order records by the total emails in descending order. Sort users with the same number 
of emails in alphabetical order.In your rankings, return a unique value (i.e., a unique rank) even if multiple 
users have the same number of emails. For tie breaker use alphabetical order of the user usernames.

My Solution: 

Select from_user, count(*) as total_emails,
ROW_NUMBER() OVER(ORDER BY count(*) desc) as rank 
From google_gmail_emails
Group by from_user
Order by total_emails DESC, from_user 

Problem 4: https://platform.stratascratch.com/coding/10322-finding-user-purchases?code_type=5

Write a query that'll identify returning active users. A returning active user is a user that has made a second purchase within 
7 days of any other of their purchases. Output a list of user_ids of these returning active users.

My Solution: 

With purchase_days AS(
Select user_id, created_at, 
Day(LEAD(created_at) OVER(Partition by user_id Order by created_at)) - Day(created_at) AS days_between_purchase
From amazon_transactions
)
Select Distinct user_id
From purchase_days
Where days_between_purchase <= 7

Problem 5: https://platform.stratascratch.com/coding/10319-monthly-percentage-difference?code_type=5

Given a table of purchases by date, calculate the month-over-month percentage change in revenue. 
The output should include the year-month date (YYYY-MM) and percentage change, rounded to the 2nd decimal point, 
and sorted from the beginning of the year to the end of the year.
The percentage change column will be populated from the 2nd month forward and can be calculated as 
((this month's revenue - last month's revenue) / last month's revenue)*100.

My Solution: 

With monthly_revenue AS(
select FORMAT(CONVERT(date, created_at), 'yyyy-MM') AS month, 
SUM(value) AS total_revenue
from sf_transactions
Group by FORMAT(CONVERT(date, created_at), 'yyyy-MM')
)
Select month,  
ROUND(100*(CAST(total_revenue - LAG(total_revenue) OVER(Order by month) AS float))/
CAST(LAG(total_revenue) OVER(Order by month) AS float),2) AS Percent_change
From monthly_revenue

Problem 6: https://platform.stratascratch.com/coding/10300-premium-vs-freemium?code_type=5

Find the total number of downloads for paying and non-paying users by date. Include only records where non-paying customers
have more downloads than paying customers. The output should be sorted by earliest date first and contain 3 columns date, 
non-paying downloads, paying downloads.

My Solution: 

SELECT date, non_paying_downloads, paying_downloads
FROM(
SELECT date, SUM(CASE WHEN paying_customer = 'yes' THEN downloads END) AS paying_downloads, 
SUM(CASE WHEN paying_customer = 'no' THEN downloads END) AS non_paying_downloads
FROM ms_user_dimension u
JOIN ms_acc_dimension a
ON u.acc_id = a.acc_id
JOIN ms_download_facts f
ON u.user_id = f.user_id
GROUP BY date) a
WHERE non_paying_downloads > paying_downloads
